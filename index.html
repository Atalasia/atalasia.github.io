<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="css/index.css">
</head>
<body>
<div class="container">
  <div class="map">
    <div id="vis"></div>
  </div>
  <div class="descbox">
     <div id="info"></div>
  </div>
</div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

  var ele = document.getElementById("vis"); // Do not use #
  var eleStyle = window.getComputedStyle(ele);
  var colWidth = parseFloat(eleStyle.width);

  var mapHeight = window.screen.availHeight * 0.7;

  var margin = {top: 10, right: 10, bottom: 10, left: 10},
    width = colWidth - margin.left - margin.right,
    height = mapHeight - margin.top - margin.bottom;

  var hexagon_diameter = 30;
  var diagram_length = 55;

  if(colWidth <= 768){
    hexagon_diameter = 20;
    height = 400- margin.top - margin.bottom;
  }

  var gridHexes = generateHexMap(hexagon_diameter, diagram_length, width/2, height/2);

  var div = d3
    .select("#info")
    .attr("class", "tooltip")       
    .style("opacity", 0);

  var svg = d3
    .select("#vis")
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .call(d3.zoom()
        .scaleExtent([1/2, 4])
        .on('zoom', function (){
            svg.attr("transform", d3.event.transform)
    }))
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var hexgrid = svg
    .selectAll("g.grid")
    .data(gridHexes)
    .enter()
    .append("g")
    .attr("transform", function(hex) {
      return "translate(" + hex.x + "," + hex.y + ")";
    });

  hexgrid
    .append("polygon")
    .attr("points", function(hex) { 
      return hex.points.map(function(d){ 
        return [d.x,d.y].join(",");}).join(" ");
    })
    .attr("stroke", "#b0b0b0")
    .attr("stroke-width", "1")
    .attr("fill", "#fcfcfc")
    .on("click", function(d) {
      if (typeof eventgrid !== 'undefined') {
        eventgrid.selectAll("polygon").attr("stroke", function(dd){ return getTileColorStroke(d);});};
      hexgrid.selectAll("polygon").attr("stroke", function(dd){ return "#b0b0b0";});
      d3.select(this).attr("stroke", function(dd){ return "#ffffff" });
      div.transition()    
        .duration(200)    
        .style("opacity", .9);    
      div.html( "(" + d.a + "," + d.b + "," + d.c + ")");
    });

  d3.json("/data/events.json", function(events){

    var eventHexes = generateCrossedPaths(hexagon_diameter, width/2, height/2, events);
    var eventgrid = svg
      .selectAll("g.grid")
      .data(eventHexes)
      .enter()
      .append("g")
      .attr("transform", function(hex) {
        return "translate(" + hex.x + "," + hex.y + ")";
      });

    eventgrid
      .append("polygon")
      .attr("points", function(hex) { 
        return hex.points.map(function(d){ 
          return [d.x,d.y].join(",");}).join(" ");
      })
      .attr("stroke", function(d){return getTileColorStroke(d);})
      .attr("stroke-width", "2")
      .attr("fill", function(d){return getTileColorFill(d);})
      .on("click", function(d){
          eventgrid.selectAll("polygon").attr("stroke", function(dd){ return getTileColorStroke(d);});
          hexgrid.selectAll("polygon").attr("stroke", function(dd){ return "#b0b0b0";});
          d3.select(this).attr("stroke", function(dd){ return "#ffffff" });
          div.transition()    
            .duration(200)    
            .style("opacity", .9);    
          div.html(infoBoxTextGen(d));
      });
  });

function infoBoxTextGen(d){

  let index = "(" + d.a + "," + d.b + "," + d.c + ")";
  let title = "<b>" + d.title + "</b>";
  
  return index + "<br><br>" + title + "<br>" + d.description + "<br><br>" + d.npcs;
}

function generateCrossedPaths(hexRadius, centerX, centerY, events){

  const sqrt3 = Math.sqrt(3);

  let r = hexRadius;
  var hexes = [];

  for(i in events){

    let event_a = events[i].a;
    let event_b = events[i].b;
    let event_c = events[i].c;

    let hexCenterX = centerX + (3/2 * r) * event_a;
    let hexCenterY = centerY + (sqrt3/2 * r) * event_a + (sqrt3 * r) * event_b;

    let hex = generateHex(r, hexCenterX, hexCenterY, event_a, event_b, event_c); //adds geometry and placement related stuff only
    
    //detailed explanations are added from here.
    hex.title = events[i].title;
    hex.description = events[i].description;
    hex.type = events[i].type;
    hex.npcs = events[i].npcs;
    hex.tt = events[i].tiletype;

    hexes.push(hex);
  }

  return hexes;
}

function generateHexMap(hexRadius, mapRadius, centerX, centerY){

  const sqrt3 = Math.sqrt(3);

  let r = hexRadius;
  var hexes = [];

  let i, j;
  for(i = -mapRadius; i <= mapRadius; i++){ //x 
    for(j = -mapRadius; j <= mapRadius; j ++){ //y

      let a = i; 
      let b = j; 
      let c = 0 - i - j;      

      if(c > mapRadius || c < -mapRadius ){
        continue;
      }

      let hexCenterX = centerX + (3/2 * r) * i;
      let hexCenterY = centerY + (sqrt3/2 * r) * i + (sqrt3 * r) * j;

      let hex = generateHex(r, hexCenterX, hexCenterY, a,b,c);

      hexes.push(hex);
    }
  }

  return hexes;
}

function generateHex(r, x, y, a, b, c){

  const sqrt3 = Math.sqrt(3);

  let hex = [];
  let vertices = [];

  //flat top, clockworkwise 
  vertices.push({x: r/2, y: sqrt3/2 * r });
  vertices.push({x: r, y: 0 });
  vertices.push({x: r/2, y: -sqrt3/2 * r });
  vertices.push({x: -r/2, y: -sqrt3/2 * r });
  vertices.push({x: -r, y: 0 });
  vertices.push({x: -r/2, y: sqrt3/2 * r });

  hex.x = x; //center position
  hex.y = y; //center position

  hex.a = a; //index
  hex.b = b; //index
  hex.c = c; //index

  hex.points = vertices;

  return hex;
}

function getTileColorStroke(d){

  switch(d.tt){
    default:
      return "#0e1111"
  }
}

function getTileColorFill(d){
  switch(d.tt){
    case "town":
      return "#0093D1";
    case "route":
      return "#eeeeee";
    case "city":
      return "#006495";
    case "poi":
      return "#e62739";
    default:
      return "#000000"
  }
}

</script>
</body>
</html>
